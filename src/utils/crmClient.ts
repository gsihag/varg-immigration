
import { supabase } from '@/integrations/supabase/client';
import type { Database } from '@/integrations/supabase/types';

type Client = Database['public']['Tables']['clients']['Row'];
type ClientInsert = Database['public']['Tables']['clients']['Insert'];
type ClientUpdate = Database['public']['Tables']['clients']['Update'];

type Document = Database['public']['Tables']['documents']['Row'];
type DocumentInsert = Database['public']['Tables']['documents']['Insert'];

type Case = Database['public']['Tables']['cases']['Row'];
type CaseInsert = Database['public']['Tables']['cases']['Insert'];

type Consultation = Database['public']['Tables']['consultations']['Row'];
type ConsultationInsert = Database['public']['Tables']['consultations']['Insert'];

type RituConversation = Database['public']['Tables']['ritu_conversations']['Row'];
type RituConversationInsert = Database['public']['Tables']['ritu_conversations']['Insert'];

export class CRMClient {
  // Client operations
  static async createClient(clientData: ClientInsert): Promise<Client | null> {
    try {
      const { data, error } = await supabase
        .from('clients')
        .insert(clientData)
        .select()
        .single();

      if (error) {
        console.error('Error creating client:', error);
        return null;
      }

      // Trigger notification webhook
      await supabase.functions.invoke('notify-new-client', {
        body: { record: data }
      });

      return data;
    } catch (error) {
      console.error('Error in createClient:', error);
      return null;
    }
  }

  static async getClientById(clientId: string): Promise<Client | null> {
    try {
      const { data, error } = await supabase
        .from('clients')
        .select('*')
        .eq('id', clientId)
        .single();

      if (error) {
        console.error('Error fetching client:', error);
        return null;
      }

      return data;
    } catch (error) {
      console.error('Error in getClientById:', error);
      return null;
    }
  }

  static async updateClient(clientId: string, updates: ClientUpdate): Promise<Client | null> {
    try {
      const { data, error } = await supabase
        .from('clients')
        .update(updates)
        .eq('id', clientId)
        .select()
        .single();

      if (error) {
        console.error('Error updating client:', error);
        return null;
      }

      return data;
    } catch (error) {
      console.error('Error in updateClient:', error);
      return null;
    }
  }

  static async getAllClients(): Promise<Client[]> {
    try {
      const { data, error } = await supabase
        .from('clients')
        .select('*')
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching clients:', error);
        return [];
      }

      return data || [];
    } catch (error) {
      console.error('Error in getAllClients:', error);
      return [];
    }
  }

  // Document operations
  static async uploadDocument(documentData: DocumentInsert): Promise<Document | null> {
    try {
      const { data, error } = await supabase
        .from('documents')
        .insert(documentData)
        .select()
        .single();

      if (error) {
        console.error('Error uploading document:', error);
        return null;
      }

      // Trigger notification webhook
      await supabase.functions.invoke('notify-document-upload', {
        body: { record: data }
      });

      return data;
    } catch (error) {
      console.error('Error in uploadDocument:', error);
      return null;
    }
  }

  static async getClientDocuments(clientId: string): Promise<Document[]> {
    try {
      const { data, error } = await supabase
        .from('documents')
        .select('*')
        .eq('client_id', clientId)
        .order('upload_date', { ascending: false });

      if (error) {
        console.error('Error fetching documents:', error);
        return [];
      }

      return data || [];
    } catch (error) {
      console.error('Error in getClientDocuments:', error);
      return [];
    }
  }

  // Case operations
  static async createCase(caseData: Omit<CaseInsert, 'case_number'>): Promise<Case | null> {
    try {
      const { data, error } = await supabase
        .from('cases')
        .insert({ ...caseData, case_number: '' }) // Will be auto-generated by trigger
        .select()
        .single();

      if (error) {
        console.error('Error creating case:', error);
        return null;
      }

      return data;
    } catch (error) {
      console.error('Error in createCase:', error);
      return null;
    }
  }

  static async getClientCases(clientId: string): Promise<Case[]> {
    try {
      const { data, error } = await supabase
        .from('cases')
        .select('*')
        .eq('client_id', clientId)
        .order('created_date', { ascending: false });

      if (error) {
        console.error('Error fetching cases:', error);
        return [];
      }

      return data || [];
    } catch (error) {
      console.error('Error in getClientCases:', error);
      return [];
    }
  }

  // Consultation operations
  static async scheduleConsultation(consultationData: ConsultationInsert): Promise<Consultation | null> {
    try {
      const { data, error } = await supabase
        .from('consultations')
        .insert(consultationData)
        .select()
        .single();

      if (error) {
        console.error('Error scheduling consultation:', error);
        return null;
      }

      return data;
    } catch (error) {
      console.error('Error in scheduleConsultation:', error);
      return null;
    }
  }

  static async getClientConsultations(clientId: string): Promise<Consultation[]> {
    try {
      const { data, error } = await supabase
        .from('consultations')
        .select('*')
        .eq('client_id', clientId)
        .order('scheduled_date', { ascending: true });

      if (error) {
        console.error('Error fetching consultations:', error);
        return [];
      }

      return data || [];
    } catch (error) {
      console.error('Error in getClientConsultations:', error);
      return [];
    }
  }

  // Ritu conversation operations
  static async saveRituConversation(conversationData: RituConversationInsert): Promise<RituConversation | null> {
    try {
      const { data, error } = await supabase
        .from('ritu_conversations')
        .insert(conversationData)
        .select()
        .single();

      if (error) {
        console.error('Error saving Ritu conversation:', error);
        return null;
      }

      return data;
    } catch (error) {
      console.error('Error in saveRituConversation:', error);
      return null;
    }
  }

  static async getClientConversations(clientId: string, sessionId?: string): Promise<RituConversation[]> {
    try {
      let query = supabase
        .from('ritu_conversations')
        .select('*')
        .eq('client_id', clientId);

      if (sessionId) {
        query = query.eq('session_id', sessionId);
      }

      const { data, error } = await query.order('timestamp', { ascending: true });

      if (error) {
        console.error('Error fetching conversations:', error);
        return [];
      }

      return data || [];
    } catch (error) {
      console.error('Error in getClientConversations:', error);
      return [];
    }
  }

  // File upload to storage
  static async uploadFileToStorage(
    bucket: 'client-documents' | 'system-templates',
    filePath: string,
    file: File
  ): Promise<string | null> {
    try {
      const { data, error } = await supabase.storage
        .from(bucket)
        .upload(filePath, file);

      if (error) {
        console.error('Error uploading file:', error);
        return null;
      }

      const { data: urlData } = supabase.storage
        .from(bucket)
        .getPublicUrl(data.path);

      return urlData.publicUrl;
    } catch (error) {
      console.error('Error in uploadFileToStorage:', error);
      return null;
    }
  }

  // Get file URL from storage
  static getFileUrl(bucket: 'client-documents' | 'system-templates', filePath: string): string {
    const { data } = supabase.storage
      .from(bucket)
      .getPublicUrl(filePath);

    return data.publicUrl;
  }
}
